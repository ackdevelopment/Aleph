module gen.CGenerator;

import std.file;
import stdio = std.stdio;
import std.range;
import std.conv;

import util;
import syntax.ctree;
import syntax.transform;

import semantics.SymbolTable;
import semantics.symbol.Symbol;

public import gen.OutputBuilder;

import std.range;
import std.algorithm;
import std.string;

public auto cgenerate(Tuple)(Tuple t, OutputStream outp)
{
    return t.expand.cgenerate(outp);
}

public auto cgenerate(CProgramNode node, SymbolTable!CSymbol table, OutputStream outp)
{
    try{
        return new CGenerator(table, new OutputBuilder(outp)).apply(node);
    }catch(Exception e){
        throw new Exception("generation error: %s".format(e.msg));
    }
}

private class CGenerator {
private:
    OutputBuilder *ob;
    alias ob this;
    SymbolTable!CSymbol symtab;
public:
    this(SymbolTable!CSymbol table, OutputBuilder *builder)
    {
        this.symtab = table;
        this.ob = builder;
    }

    invariant
    {
        assert(this.ob, "No output builder");
        assert(this.symtab, "No symbol table");
    }
    
    auto apply(CProgramNode node)
    {
        this.ob.printfln("/* Generated by the Aleph compiler v0.0.1 */");
        this.visit(node);
        return this.ob;
    }

    void visit(CProgramNode node)
    {
        foreach(x; node.children){
            this.visit(x);
        }
    }

    void visit(CTopLevelNode node)
    {
        node.match(
            (CFuncDeclNode func) => this.visit(func)
        );
    }

    void visit(CFuncDeclNode node)
    {
        this.untabbed({
            string inside = node.name ~ "(";
            node.parameters.headLast!(
                    i => inside ~= ("%s, ".format(i.type.typeString(i.name))),
                    k => inside ~= ("%s".format(k.type.typeString(k.name))));
            inside ~= ")";
            import std.stdio;
            this.printf("%s %s",  node.storageClass.toString,
                                  node.returnType.typeString(inside));
        });
        this.visit(node.bodyNode);
    }

    void visit(CBlockStatementNode node)
    {
        this.block({
            node.children.each!(x => this.visit(x));
        });
    }

    void visit(CStatementNode node)
    {
        node.match(
            (CExpressionNode n){
                this.statement({
                    this.visit(n);
                });
            },
            (CReturnNode n){
                this.statement({
                    this.printf("return ");
                    this.untabbed({
                        this.visit(n.exp);
                    });
                });
            },
            (CBlockStatementNode n) => this.visit(n),
            (CTypedefNode n) => this.visit(n),
            (CVarDeclNode n) => this.visit(n),
            (CStatementNode n){ this.printfln(";"); }
        );
    }

    void visit(CVarDeclNode node)
    {
        import std.string;
        this.statement({
            this.printf("%s %s", node.storageClass.toString, node.type.typeString(node.name));
            if(node.initVal){
                this.untabbed({
                    this.printf(" = ");
                    this.visit(node.initVal);
                });
            }
        });
    }

    void visit(CExpressionNode node)
    {
        import std.stdio;
        node.match(
            (CLiteralNode x){
                this.printf(x.match(
                                   (StringLiteral x) => x.value,
                                   (IntLiteral x) => x.value.to!string)
                );
            },
            (CIdentifierNode n){
                this.printf("%s", n.name);
            },
            (CCallNode n){
                this.visit(n.toCall);
                this.untabbed({
                    this.printf("(");
                    n.arguments.headLast!((x){ this.visit(x); this.printf(", "); },
                                          (k){ this.visit(k); });
                    this.printf(")");
                });
            }
        );
    }

    void visit(CTypedefNode node)
    {
        node.ctype.match(
            (CFunctionType x) => this.printfln("typedef %s", node.ctype.typeString(node.totype)),
            (CType x) => this.printfln("typedef %s %s;", node.ctype.typeString(node.totype), node.totype)
        );
        
    }
};

private string typeString(CType t, string id)
{
    import util;
    return t.use_err!(t => t.match((CPrimitive t) => "%s%s".format(t.name, (id.length == 0 ? "" : " " ~ id)),
                                   (CPointerType t) => t.type.typeString("*" ~ id),
                                   (CFunctionType t){
                                       string inside = "(*" ~ id ~ ")";
                                       inside ~= "(";
                                       t.parameterTypes.each!(
                                           x => inside ~= x.typeString("")
                                       );
                                       inside ~= ")";
                                       return t.returnType.typeString(inside);
                                   },
                                   (CType t) => null))(new Exception("Unknown type %s".format(t)));
}
